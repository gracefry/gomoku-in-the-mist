        -:    0:Source:gitm.c
        -:    0:Graph:gitm.gcno
        -:    0:Data:gitm.gcda
        -:    0:Runs:15
        -:    1:// name: Grace Fry
        -:    2:// unikey: gfry4533
        -:    3:// SID: 520351277
        -:    4:
        -:    5:#include <stdio.h>
        -:    6:#include <string.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <ctype.h>
        -:    9:
        -:   10:#define BOARD_SIZE 19
        -:   11:#define MAX_TURN 361
        -:   12:
        -:   13:char board[BOARD_SIZE + 2][BOARD_SIZE + 2];
        -:   14:
        -:   15:char command[512];
        -:   16:int game_over = 0;
        -:   17:int turn = 0;
        -:   18:
        -:   19:char history[MAX_TURN][4];
        -:   20:int hist_i = 0;
        -:   21:
        -:   22:int mist_centre[2] = {10, 10}; // Starts in middle
        -:   23:
       15:   24:void make_board() {
      300:   25:    for (int col = 1; col <= BOARD_SIZE; col++) {
     5700:   26:        for (int row = 1; row <= BOARD_SIZE; row++) {
     5415:   27:            board[col][row] = '.';
        -:   28:        }
        -:   29:    }
       15:   30:}
        -:   31:
       12:   32:void print_history() {
      449:   33:    for (int i = 0; i < hist_i; i++) {
      437:   34:        printf("%s", history[i]);
        -:   35:    }
       12:   36:    printf("\n");
       12:   37:}
        -:   38:
        6:   39:void term() {
        -:   40:    /*
        -:   41:    * Function:  term
        -:   42:    * --------------------
        -:   43:    * Forces the controller to terminate with exit code 1. 
        -:   44:    * This command can be executed at any time. 
        -:   45:    * This command will suppress history moves messages and the exit message.
        -:   46:    */
        -:   47:
        6:   48:    exit(1);
        -:   49:}
        -:   50:
      917:   51:char who(int turn) {
        -:   52:    /*
        -:   53:    * Function:  who 
        -:   54:    * --------------------
        -:   55:    * Shows who is the current player. 
        -:   56:    * This command can be executed at any time.
        -:   57:    *
        -:   58:    *   turn: integer value of the current turn 
        -:   59:    *       turn increments by 1 for every valid place command
        -:   60:    *
        -:   61:    *   returns: 
        -:   62:    *       char 'B' for black, or
        -:   63:    *       char 'W' for white
        -:   64:    */
        -:   65:
      917:   66:    return (turn % 2 == 0) ? 'B' : 'W';;
        -:   67:}
        -:   68:
      438:   69:int won(int num_c, int r, char player) {
      438:   70:    int count = 1;
      438:   71:    char moku = (player == 'W') ? 'o' : '#';
        -:   72:
        -:   73:    // Check vertical increasing
      438:   74:    for (int row = (r + 1); 
      448:   75:        row < (r + 5) || row < BOARD_SIZE; row++) {
        -:   76:        // printf("Check vertical increasing\n");
      447:   77:        if (board[num_c][row] == moku) {
       10:   78:            count++;
        -:   79:        } else {
      437:   80:            break;
        -:   81:        }
        -:   82:    }
        -:   83:
        -:   84:    // Check vertical decreasing
      438:   85:    for (int row = (r - 1); 
      803:   86:        row > (r - 5) && row >= 0; row--) {
        -:   87:        // printf("Check vertical decreasing\n");
      802:   88:        if (board[num_c][row] == moku) {
      365:   89:            count++;
        -:   90:        } else {
      437:   91:            break;
        -:   92:        }
        -:   93:    }
        -:   94:
      438:   95:    if (count == 5) {
        2:   96:        return 1;
        -:   97:    } else {
      436:   98:        count = 1;
        -:   99:    }
        -:  100:    
        -:  101:
        -:  102:    // Check horizontal increasing
      436:  103:    for (int col = (num_c + 1); 
      439:  104:        col < (num_c + 5) && col < BOARD_SIZE; col++) {
      394:  105:        if (board[col][r] == moku) {
        3:  106:            count++;
        -:  107:        } else {
      391:  108:            break;
        -:  109:        }
        -:  110:    }
        -:  111:
        -:  112:    // Check horizontal decreasing
      436:  113:    for (int col = (num_c - 1); 
      452:  114:        col > (num_c - 5) && col >= 0; col--) {
      450:  115:        if (board[col][r] == moku) {
       16:  116:            count++;
        -:  117:        } else {
      434:  118:            break;
        -:  119:        }
        -:  120:    }
        -:  121:
      436:  122:    if (count == 5) {
        2:  123:        return 1;
        -:  124:    } else {
      434:  125:        count = 1;
        -:  126:    }
        -:  127:
        -:  128:    // Check diagonal SE
      434:  129:    for (int col = (num_c + 1), row = (r + 1); 
      443:  130:        col < (num_c) + 5 && col < BOARD_SIZE && row < BOARD_SIZE && row < (r + 5); 
        9:  131:        col++, row++) {
      362:  132:        if (board[col][row] == moku) {
        9:  133:            count++;
        -:  134:        } else {
      353:  135:            break;
        -:  136:        }
        -:  137:    }
        -:  138:
        -:  139:    // Check diagonal NW
      434:  140:    for (int col = num_c - 1, row = (r - 1); 
      569:  141:        col > num_c - 5 && col >= 0 && row >= 0 && row > (r - 5); 
      135:  142:        col--, row--) {
      567:  143:        if (board[col][row] == moku) {
      135:  144:            count++;
        -:  145:        } else {
      432:  146:            break;
        -:  147:        }
        -:  148:    }
        -:  149:
      434:  150:    if (count == 5) {
        2:  151:        return 1;
        -:  152:    } else {
      432:  153:        count = 1;
        -:  154:    }
        -:  155:
        -:  156:    // Check diagonal SW
      432:  157:    for (int col = (num_c - 1), row = (r + 1); 
      443:  158:        col > (num_c - 5) && col >= 0 && row < BOARD_SIZE && row < (r + 5); 
       11:  159:        col--, row++) {
      401:  160:        if (board[col][row] == moku) {
       11:  161:            count++;
        -:  162:        } else {
      390:  163:            break;
        -:  164:        }
        -:  165:    }
        -:  166:
        -:  167:    // Check diagonal NE
      432:  168:    for (int col = (num_c + 1), row = (r - 1); 
      534:  169:        col < (num_c + 5) && col < BOARD_SIZE && row > (r - 5) && row >= 0; 
      102:  170:        col++, row--) {
      483:  171:        if (board[col][row] == moku) {
      102:  172:            count++;
        -:  173:        } else {
      381:  174:            break;
        -:  175:        }
        -:  176:    }
        -:  177:
      432:  178:    if (count == 5) {
        1:  179:        return 1;
        -:  180:    } else {
      431:  181:        return 0;
        -:  182:    }
        -:  183:}
        -:  184:
        8:  185:void victory(char player) {
        8:  186:    char* name = (player == 'W') ? "White" : "Black";
        -:  187:
        8:  188:    printf("%s wins!\n", name);
        8:  189:    print_history();
        8:  190:    printf("Thank you for playing!\n");
        8:  191:    game_over = 1;
        8:  192:}
        -:  193:
        1:  194:void resign() {
        1:  195:    turn++;
        1:  196:    char player = who(turn);
        1:  197:    victory(player);
        1:  198:}
        -:  199:
      438:  200:void place(char c, int r, char player) {
      438:  201:    int num_c = command[6] - 'A' + 1;
        -:  202:    
        -:  203:    // Place according to player
      438:  204:    if (player == 'B') {
      223:  205:        board[num_c][r] = '#';
        -:  206:    } else {
      215:  207:        board[num_c][r] = 'o';
        -:  208:    }
        -:  209:
        -:  210:    // Add to history
        -:  211:    char coord[4]; 
      438:  212:    sprintf(coord,"%c%d", c, r);
      438:  213:    strcpy(history[hist_i], coord);
      438:  214:    hist_i++;
        -:  215:
        -:  216:    // Update mist centre
      438:  217:    int mist_col = 1 + (5 * (num_c * num_c) + 3 * num_c + 4) % 19;
      438:  218:    int mist_row = 1 + (4 * (r * r) + 2 * r - 4) % 19;
      438:  219:    mist_centre[0] = mist_col;
      438:  220:    mist_centre[1] = mist_row;
        -:  221:
        -:  222:    // Check win
      438:  223:    if (!won(num_c, r, player)) {
      431:  224:        turn++;
        -:  225:    } else {
        7:  226:        victory(player);
        -:  227:    }
      438:  228:}
        -:  229:
      446:  230:int check_validity(char* command) {
      446:  231:    char c = command[6];
      446:  232:    int num_c = c - 'A' + 1;
      446:  233:    int r = 0;
        -:  234:
      446:  235:    if (command[6] == '\n' || command[6] == ' ') {
        1:  236:        return 1;
        -:  237:    }
        -:  238:
     1099:  239:    for (int i = 7; command[i] != '\n'; i++) {
      656:  240:        if (command[i] == ' ') {
        1:  241:            return 1;
        -:  242:        }
      655:  243:        if (command[i] <= '9' && command[i] >= '0') {
      654:  244:            r = r * 10 + command[i] - '0';
        -:  245:        } else {
        1:  246:            return 2;
        -:  247:        }
        -:  248:    }
        -:  249:
      443:  250:    if (command[7] == '0') {
        2:  251:        return 2;
        -:  252:    }
        -:  253:
      441:  254:    if ((num_c < 1 || num_c > BOARD_SIZE) || 
      440:  255:        (r < 1 || r > BOARD_SIZE)) {
        2:  256:        return 2;
        -:  257:    } 
        -:  258:
      439:  259:    if (board[num_c][r] != '.') {
        1:  260:        return 3;
        -:  261:    }
        -:  262:
      438:  263:    place(c, r, who(turn));
        -:  264:
      438:  265:    return 0;
        -:  266:}
        -:  267:
        5:  268:void view() {
        5:  269:    int mist_col = mist_centre[0];
        5:  270:    char c_mist_col = mist_col + 'A' - 1;
        5:  271:    int mist_row = mist_centre[1];
        5:  272:    printf("%c%d,", c_mist_col, mist_row);
        -:  273:    
       40:  274:    for (int row = mist_row + 3; row >= mist_row - 3; row--) {
      280:  275:        for (int col = mist_col - 3; col <= mist_col + 3; col++) {
      245:  276:            if (col < 1 || col > BOARD_SIZE ||
      195:  277:                row < 1 || row > BOARD_SIZE) {
       57:  278:                printf("x");
        -:  279:            } else {
      188:  280:                printf("%c", board[col][row]);
        -:  281:            }
        -:  282:        }
        -:  283:    }
        -:  284:
        -:  285:    // for (int col = 1; col <= BOARD_SIZE; col++) {
        -:  286:    //     printf("%c ", col + 'A' - 1);
        -:  287:    // }
        -:  288:    // printf("\n");
        -:  289:
        -:  290:    // for (int row = 1; row <= BOARD_SIZE; row++) {
        -:  291:    //     printf("%2d ", row);
        -:  292:    //     for (int col = 1; col <= BOARD_SIZE; col++) {
        -:  293:    //         printf("%c ", board[col][row]);
        -:  294:    //     }
        -:  295:    //     printf("\n");
        -:  296:    // }
        -:  297:
        5:  298:    printf("\n");
        5:  299:}
        -:  300:
       15:  301:int main(int argc, char* argv[]) {
       15:  302:    make_board();
        -:  303:
      487:  304:    while (!game_over) {
      478:  305:        fgets(command, 256, stdin);
      478:  306:        char player = who(turn);
        -:  307:
        -:  308:        // command switcher
      478:  309:        if (!strcmp(command, "term\n")) {
        6:  310:            term();
      472:  311:        } else if (!strcmp(command, "who\n")) {
       12:  312:            printf("%c\n", player);
       12:  313:            continue;
      460:  314:        } else if (!strcmp(command, "history\n")) {
        3:  315:            print_history();
        3:  316:            continue;
      457:  317:        } else if (!strcmp(command, "view\n")) {
        5:  318:            view();
        5:  319:            continue;
      452:  320:        } else if (!strcmp(command, "resign\n")) {
        1:  321:            resign();
        1:  322:            continue;
      451:  323:        } else if (!strncmp(command, "place ", 6)) {
      446:  324:            switch (check_validity(command)) {
        2:  325:                case 1:
        2:  326:                    printf("Invalid!\n");
        2:  327:                    break;
        5:  328:                case 2:
        5:  329:                    printf("Invalid coordinate\n");
        5:  330:                    break;
        1:  331:                case 3:
        1:  332:                    printf("Occupied coordinate\n");
        1:  333:                    break;
      438:  334:                default:
      438:  335:                    break;
        -:  336:            }
        -:  337:        } else {
        5:  338:            printf("Invalid!\n");
        -:  339:        }
        -:  340:        // tie
      451:  341:        if (turn == MAX_TURN) {
        1:  342:            printf("Wow, a tie!\n");
        1:  343:            print_history();
        1:  344:            printf("Thank you for playing!\n");
        1:  345:            game_over = 1;
        -:  346:        }
        -:  347:    }
        -:  348:
        9:  349:    return 0;
        -:  350:}
